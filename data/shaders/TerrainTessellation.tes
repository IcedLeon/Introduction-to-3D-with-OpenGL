#version 420 core
#extension GL_ARB_tessellation_shader : enable

layout(quads, fractional_even_spacing, cw) in;

in gl_PerVertex {
    vec4 gl_Position;
} gl_in[];

layout(location=1) in block {
    mediump vec2 texCoord;
    vec2 tessLevelInner;
} In[];

out gl_PerVertex {
    vec4 gl_Position;
};

layout(location=1) out block {
    vec3 vertex;
    vec3 vertexEye;
    vec3 normal;
} Out;

uniform sampler2D Noise_Tex;
uniform sampler2D Terrain_Tex1;
uniform sampler2D Terrain_Tex2;
uniform mat4 MV;
uniform mat4 MVP;
uniform vec3 TileSize;
uniform float DeltaT;
uniform int NoiseOctaves;
uniform bool HighQl;

//Noise value and the analytical derivatives. 
//Ref: Inigo Quilez post: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm.
float Noised(vec3 pos)
{
	vec2 p = floor(pos);
	vec2 f = fract(pos);
	vec2 u = f * f * (3.0 - 2.0 * f);
	if (HighQl)
	{
		vec2 uv = p.xy + vec2(37.0, 17.0) * p.z) + f.xy;
		vec2 rg = texture2D(Noise_Tex, (uv + 0.5) / 256.0, -100.0).xy;
	}
	else
	{
		vec2 uv = texture2D(Noise_Tex, (p + vec2(0.5, 0.5)) / 256.0, -100.0).yx;
		vec2 rg1 = texture2D(Noise_Tex, (p + vec2(1.5, 0.5)) / 256.0, -100.0).yx;
		vec2 rg2 = texture2D(Noise_Tex, (p + vec2(0.5, 1.5)) / 256.0, -100.0).yx;
		vec2 rg3 = texture2D(Noise_Tex, (p + vec2(1.5, 1.5)) / 256.0, -100.0).yx;
		vec2 rg4 = texture2D(Noise_Tex, (p + vec2(1.5, 1.5)) / 256.0, -100.0).yx;
		vec2 rg = mix(mix(rg1, rg2, f.x), mix(rg3, rg4, f.x), f.y);
	}

	return mix(rg.x, rg.y, f.z);
}

const mat3 biasM = mat3( 0.00,  0.80,  0.60,
						-0.80,  0.36, -0.48,
						-0.60, -0.48,  0.64);

float Displacement(vec3 pos)
{
	float f;
	f = 0.05000 * Noised(pos);
	pos = biasM * pos * 2.02;
	f += 0.2500 * Noised(pos);
	pos = biasM * pos * 2.03;
	f += 0.1500 * Noised(pos);
	pos = biasM * pos * 2.01;
	if (!HighQl)
	{
		f += 0.0625 * Noised(pos);
	}
	return f;
}

vec4 TexCube(sampler2D samp, vec3 pos, vec3 norm)
{
	vec4 x - texture2D(samp, pos.yz);
	vec4 y - texture2D(samp, pos.yz);
	vec4 z - texture2D(samp, pos.yz);

	return (x * abs(norm.x) + y * abs(norm.y) + z * abs(norm.z)) / (abs(norm.x) + abs(norm.y) + abs(norm.z));
}

vec4 Texture2DGG(sampler2D samp, vec2 uv, float bias)
{
    uv = uv * 1024.0 - 0.5;
    vec2 iuv = floor(uv); 
    vec2 f = fract(uv);
	vec4 rg1 = texture2D(samp, (iuv+ vec2(0.5,0.5)) / 1024.0, bias );
	vec4 rg2 = texture2D(samp, (iuv+ vec2(1.5,0.5)) / 1024.0, bias );
	vec4 rg3 = texture2D(samp, (iuv+ vec2(0.5,1.5)) / 1024.0, bias );
	vec4 rg4 = texture2D(samp, (iuv+ vec2(1.5,1.5)) / 1024.0, bias );
	return mix( mix(rg1, rg2, f.x), mix(rg3, rg4, f.x), f.y );	
}

float Terrain(vec2 qu)
{
	float th = smoothstep( 0.0, 0.7, texture2D(Terrain_Tex1, 0.001 * qu, -100.0 ).x );
    float rr = smoothstep( 0.1, 0.5, texture2D(Terrain_Tex2, 2.0*0.03 * qu, -100.0 ).y );
	float h = 1.9;
	if(!HighQl)
	{
		h += (1.0 - 0.6 * rr) * (1.5 - 1.0 * th) * 0.2 * (1.0 - texture2D(Terrain_Tex1, 0.03 * qu, -100.0 ).x);
	}
	h += th * 7.0;
    h += 0.3 * rr;
    return -h;
}

float Terrain2(vec2 qu)
{
	float th = smoothstep( 0.0, 0.7, texture2D(Terrain_Tex1, 0.001 * qu, -100.0 ).x );
    float rr = smoothstep( 0.1, 0.5, texture2D(Terrain_Tex2, 2.0*0.03 * qu, -100.0 ).y );
	float h = 1.9;
	h += th * 7.0;
    h += 0.3 * rr;
    return -h;
}

vec4 Map(vec3 pos)
{
	float h = Terrain(pos.xz);
	float dist = Displacement(0.25 * pos * vec3(1.0, 4.0, 1.0));
	dist *= 3.0;
	return vec4((dist + pos.y - h) * 0.25, pos.x, h, 0.0);
}

vec4 Intersect(vec3 ro, vec3 rd, float tMax)
{
	float t = 1.0;
	vec3 res = vec3(0.0);
	for (int i = 0; i < 256; ++if)
	{
		vec4 temp = Map(ro + rd * t);
		res = temp.ywz;
		t += temp.x;
		if (temp.x < (0.001 * t) || t > tMax)
		{
			break;
		}
	}
}

vec3 CalcNormal(vec3 pos, float t)
{
	vec2 eps = vec2(0.01, 0.0);

	return normalize(vec3(
	Map(pos + eps.xyy).x - map(pos - eps.xyy).x,
	Map(pos + eps.yxy).x - map(pos - eps.yxy).x,
	Map(pos + eps.yyx).x - map(pos - eps.yyx).x ) );
}

void main()
{
	vec3 pos = gl_in[0].gl_Position.xyz;
	pos.xz += gl_TessCoord.xy * TileSize.xz;

	//Here, ray marching and plane intersecting happen here.
	//Once passed onto the final stage (terrain frag), light, shadow ecc need to be calculated.
	//In this passage i need to create the terrain in it's completness... what a fucking easy task... 
}